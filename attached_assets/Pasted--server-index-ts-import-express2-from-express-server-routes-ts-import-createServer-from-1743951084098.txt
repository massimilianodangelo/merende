// server/index.ts
import express2 from "express";

// server/routes.ts
import { createServer } from "http";

// server/storage.ts
import session from "express-session";
import createMemoryStore from "memorystore";
import fs from "fs";
import path from "path";
var storageDir = path.join(process.cwd(), "storage");
if (!fs.existsSync(storageDir)) {
  fs.mkdirSync(storageDir);
}
var dataFilePath = path.join(storageDir, "app-data.json");
var Storage = {
  // Salva i dati nel file
  saveData: (key, value) => {
    try {
      let data = {};
      if (fs.existsSync(dataFilePath)) {
        const fileData = fs.readFileSync(dataFilePath, "utf8");
        if (fileData) {
          data = JSON.parse(fileData);
        }
      }
      data[key] = value;
      fs.writeFileSync(dataFilePath, JSON.stringify(data, null, 2), "utf8");
      console.log(`Dati salvati con chiave: ${key}`);
    } catch (error) {
      console.error("Errore nel salvataggio dei dati:", error);
    }
  },
  // Carica i dati dal file
  loadData: (key) => {
    try {
      if (fs.existsSync(dataFilePath)) {
        const fileData = fs.readFileSync(dataFilePath, "utf8");
        if (fileData) {
          const data = JSON.parse(fileData);
          return data[key] || null;
        }
      }
    } catch (error) {
      console.error("Errore nel caricamento dei dati:", error);
    }
    return null;
  },
  // Elimina una chiave di dati
  removeData: (key) => {
    try {
      if (fs.existsSync(dataFilePath)) {
        let data = JSON.parse(fs.readFileSync(dataFilePath, "utf8"));
        if (data && data[key]) {
          delete data[key];
          fs.writeFileSync(dataFilePath, JSON.stringify(data, null, 2), "utf8");
          console.log(`Dati rimossi con chiave: ${key}`);
        }
      }
    } catch (error) {
      console.error("Errore nella rimozione dei dati:", error);
    }
  },
  // Pulisce tutti i dati
  clearData: () => {
    try {
      fs.writeFileSync(dataFilePath, "{}", "utf8");
      console.log("Tutti i dati sono stati rimossi");
    } catch (error) {
      console.error("Errore nella pulizia dei dati:", error);
    }
  }
};
var MemoryStore = createMemoryStore(session);
var MemStorage = class {
  users;
  products;
  orders;
  orderItems;
  availableClasses;
  sessionStore;
  userId;
  productId;
  orderId;
  orderItemId;
  deletedUserIds = [];
  // Array per memorizzare gli ID degli utenti eliminati
  constructor() {
    try {
      const savedData = Storage.loadData("appData");
      if (savedData) {
        this.users = new Map(savedData.users);
        this.products = new Map(savedData.products);
        this.orders = new Map(savedData.orders);
        this.orderItems = new Map(savedData.orderItems);
        this.userId = savedData.userId;
        this.productId = savedData.productId;
        this.orderId = savedData.orderId;
        this.orderItemId = savedData.orderItemId;
        this.deletedUserIds = savedData.deletedUserIds || [];
        if (this.deletedUserIds.length > 0) {
          this.deletedUserIds.sort((a, b) => a - b);
        }
        console.log("Dati caricati dal file di storage");
      } else {
        this.users = /* @__PURE__ */ new Map();
        this.products = /* @__PURE__ */ new Map();
        this.orders = /* @__PURE__ */ new Map();
        this.orderItems = /* @__PURE__ */ new Map();
        this.userId = 1;
        this.productId = 1;
        this.orderId = 1;
        this.orderItemId = 1;
        this.createAdminUser();
        this.initializeProducts();
        console.log("Nuovi dati inizializzati");
      }
    } catch (error) {
      console.error("Errore nel caricamento dei dati:", error);
      this.users = /* @__PURE__ */ new Map();
      this.products = /* @__PURE__ */ new Map();
      this.orders = /* @__PURE__ */ new Map();
      this.orderItems = /* @__PURE__ */ new Map();
      this.userId = 1;
      this.productId = 1;
      this.orderId = 1;
      this.orderItemId = 1;
      this.createAdminUser();
      this.initializeProducts();
    }
    try {
      const savedClasses = Storage.loadData("availableClasses");
      if (savedClasses) {
        this.availableClasses = savedClasses;
      } else {
        this.availableClasses = [];
      }
    } catch (error) {
      console.error("Errore nel caricamento delle classi:", error);
      this.availableClasses = [];
    }
    this.sessionStore = new MemoryStore({
      checkPeriod: 864e5
      // 24 hours
    });
  }
  // Salva i dati nel file di storage
  saveData() {
    try {
      const dataToSave = {
        users: Array.from(this.users.entries()),
        products: Array.from(this.products.entries()),
        orders: Array.from(this.orders.entries()),
        orderItems: Array.from(this.orderItems.entries()),
        userId: this.userId,
        productId: this.productId,
        orderId: this.orderId,
        orderItemId: this.orderItemId,
        deletedUserIds: this.deletedUserIds
        // Salva anche gli ID utente eliminati
      };
      Storage.saveData("appData", dataToSave);
    } catch (error) {
      console.error("Errore nel salvataggio dei dati:", error);
    }
  }
  // Initialize sample products
  initializeProducts() {
    const sampleProducts = [
      {
        name: "TRAMEZZINO TONNO E POMODORO",
        description: "Tramezzino con tonno e pomodoro",
        price: 2,
        category: "Tramezzini",
        available: true
      },
      {
        name: "TRAMEZZINO PROSCIUTTO COTTO",
        description: "Tramezzino con prosciutto cotto e formaggio edamer",
        price: 2,
        category: "Tramezzini",
        available: true
      },
      {
        name: "TRAMEZZINO PROSCIUTTO CRUDO",
        description: "Tramezzino con prosciutto crudo e formaggio edamer",
        price: 2,
        category: "Tramezzini",
        available: true
      },
      {
        name: "TRAMEZZINO SALAME",
        description: "Tramezzino con salame e formaggio edamer",
        price: 2,
        category: "Tramezzini",
        available: true
      },
      {
        name: "CALZONE AL FORNO",
        description: "Calzone al forno con prosciutto cotto e mozzarella",
        price: 2,
        category: "Calzoni",
        available: true
      },
      {
        name: "PANINO TONDO PROSCIUTTO CRUDO",
        description: "Panino tondo con prosciutto crudo",
        price: 2.5,
        category: "Panini",
        available: true
      },
      {
        name: "PANINO TONDO PETTO DI TACCHINO",
        description: "Panino tondo con petto di tacchino arrosto, rucola, grana e olio d'oliva",
        price: 2.5,
        category: "Panini",
        available: true
      },
      {
        name: "PANINO TONDO PROSCIUTTO COTTO",
        description: "Panino tondo con prosciutto cotto",
        price: 2.5,
        category: "Panini",
        available: true
      },
      {
        name: "PANINO TONDO SALAME",
        description: "Panino tondo con salame",
        price: 2.5,
        category: "Panini",
        available: true
      },
      {
        name: "PANINO TONDO HAMBURGER",
        description: "Panino tondo con hamburger di manzo, lattuga e pomodoro",
        price: 2.5,
        category: "Panini",
        available: true
      },
      {
        name: "PIZZA BIANCA SEMPLICE",
        description: "Pizza bianca semplice",
        price: 1,
        category: "Pizze",
        available: true
      },
      {
        name: "PIZZA ROSSA SEMPLICE",
        description: "Pizza rossa con pomodoro",
        price: 1.5,
        category: "Pizze",
        available: true
      },
      {
        name: "PIZZA PATATE",
        description: "Pizza con patate",
        price: 1.5,
        category: "Pizze",
        available: true
      }
    ];
    sampleProducts.forEach((product) => {
      this.createProduct(product);
    });
  }
  // Crea gli utenti amministratori predefiniti
  async createAdminUser() {
    const existingAdmin = await this.getUserByUsername("prova@amministratore.it");
    if (!existingAdmin) {
      const salt = "c0ffee12deadbeef34abcd5678";
      const password = "Prova2025!";
      const crypto = await import("crypto");
      const hashedPassword = crypto.createHash("sha256").update(password + salt).digest("hex") + "." + salt;
      const adminUser = {
        username: "prova@amministratore.it",
        password: hashedPassword,
        // Password con hash
        firstName: "Admin",
        lastName: "System",
        classRoom: "Admin",
        email: "prova@amministratore.it",
        isAdmin: true,
        isRepresentative: false
      };
      const user = await this.createUser(adminUser);
      console.log("Utente amministratore principale creato:", user.username);
    } else {
      console.log("Utente amministratore principale gi\xE0 esistente:", existingAdmin.username);
    }
    const existingUserAdmin = await this.getUserByUsername("gestione@amministratore.it");
    if (!existingUserAdmin) {
      const salt = "f1b2c3d4e5f6789abcdef123";
      const password = "Gestione2025!";
      const crypto = await import("crypto");
      const hashedPassword = crypto.createHash("sha256").update(password + salt).digest("hex") + "." + salt;
      const userAdminUser = {
        username: "gestione@amministratore.it",
        password: hashedPassword,
        firstName: "Gestione",
        lastName: "Utenti",
        classRoom: "Admin",
        email: "gestione@amministratore.it",
        isAdmin: false,
        // Non è un amministratore generale
        isRepresentative: false,
        isUserAdmin: true
        // Flag per identificare gli admin di gestione utenti
      };
      const user = await this.createUser(userAdminUser);
      console.log("Utente amministratore per gestione utenti creato:", user.username);
    } else {
      console.log("Utente amministratore per gestione utenti gi\xE0 esistente:", existingUserAdmin.username);
    }
  }
  // User operations
  async getUser(id) {
    return this.users.get(id);
  }
  async getUserByUsername(username) {
    return Array.from(this.users.values()).find(
      (user) => user.username === username
    );
  }
  async getAllUsers() {
    return Array.from(this.users.values());
  }
  async updateUser(id, userData) {
    const existingUser = this.users.get(id);
    if (!existingUser) {
      return void 0;
    }
    const updatedUser = { ...existingUser, ...userData };
    this.users.set(id, updatedUser);
    this.saveData();
    return updatedUser;
  }
  async deleteUser(id) {
    const existingUser = this.users.get(id);
    if (!existingUser) {
      console.log(`deleteUser: Utente con ID ${id} non trovato`);
      return false;
    }
    console.log(`deleteUser: Eliminazione utente con ID ${id} (${existingUser.firstName} ${existingUser.lastName})`);
    const userOrders = Array.from(this.orders.values()).filter((order) => order.userId === id);
    for (const order of userOrders) {
      const orderItems2 = Array.from(this.orderItems.values()).filter((item) => item.orderId === order.id);
      for (const item of orderItems2) {
        this.orderItems.delete(item.id);
      }
      this.orders.delete(order.id);
    }
    this.users.delete(id);
    if (!this.deletedUserIds.includes(id)) {
      console.log(`deleteUser: Aggiunto ID ${id} all'array deletedUserIds`);
      this.deletedUserIds.push(id);
    } else {
      console.log(`deleteUser: ID ${id} gi\xE0 presente nell'array deletedUserIds`);
    }
    this.deletedUserIds.sort((a, b) => a - b);
    console.log(`deleteUser: Array deletedUserIds aggiornato: [${this.deletedUserIds.join(", ")}]`);
    this.saveData();
    return true;
  }
  async createUser(insertUser) {
    let id;
    const savedData = Storage.loadData("appData");
    if (savedData && savedData.deletedUserIds) {
      this.deletedUserIds = savedData.deletedUserIds;
      console.log(`createUser: Caricati ID eliminati: [${this.deletedUserIds.join(", ")}]`);
    }
    if (this.deletedUserIds.length > 0) {
      this.deletedUserIds.sort((a, b) => a - b);
      id = this.deletedUserIds.shift();
      console.log(`createUser: Riutilizzo ID utente eliminato: ${id}`);
    } else {
      let maxId = 0;
      if (savedData && savedData.users) {
        const userIds = savedData.users.map((userEntry) => userEntry[0]);
        if (userIds.length > 0) {
          maxId = Math.max(...userIds);
          console.log(`createUser: ID utente massimo trovato: ${maxId}`);
        }
      } else {
        maxId = this.userId - 1;
        console.log(`createUser: Nessun utente esistente, ID massimo inizializzato a: ${maxId}`);
      }
      id = maxId + 1;
      console.log(`createUser: Assegnato nuovo ID utente sequenziale: ${id}`);
    }
    if (id >= this.userId) {
      this.userId = id + 1;
    }
    const isAdmin = insertUser.email === "prova@amministratore.it" || !!insertUser.isAdmin;
    const isUserAdmin = insertUser.email === "gestione@amministratore.it" || !!insertUser.isUserAdmin;
    const isRepresentative = !!insertUser.isRepresentative;
    const user = {
      ...insertUser,
      id,
      isRepresentative,
      isAdmin,
      isUserAdmin
    };
    this.users.set(id, user);
    this.saveData();
    return user;
  }
  // Product operations
  async getProducts() {
    return Array.from(this.products.values());
  }
  async getProductsByCategory(category) {
    if (category === "Tutti") {
      return Array.from(this.products.values());
    }
    return Array.from(this.products.values()).filter(
      (product) => product.category === category
    );
  }
  async getProduct(id) {
    return this.products.get(id);
  }
  async createProduct(insertProduct) {
    const id = this.productId++;
    const product = {
      ...insertProduct,
      id,
      available: insertProduct.available !== void 0 ? insertProduct.available : true
    };
    this.products.set(id, product);
    this.saveData();
    return product;
  }
  async updateProduct(id, product) {
    const existingProduct = this.products.get(id);
    if (!existingProduct) {
      return void 0;
    }
    const updatedProduct = { ...existingProduct, ...product };
    this.products.set(id, updatedProduct);
    this.saveData();
    return updatedProduct;
  }
  async deleteProduct(id) {
    const existingProduct = this.products.get(id);
    if (!existingProduct) {
      return false;
    }
    this.products.delete(id);
    this.saveData();
    return true;
  }
  // Order operations
  async getOrders() {
    return Array.from(this.orders.values());
  }
  async getOrdersByUser(userId) {
    return Array.from(this.orders.values()).filter(
      (order) => order.userId === userId
    );
  }
  async getOrdersByDate(date) {
    const targetDate = new Date(date.toDateString());
    return Array.from(this.orders.values()).filter((order) => {
      const orderDate = new Date(order.orderDate.toDateString());
      return orderDate.getTime() === targetDate.getTime();
    });
  }
  async getOrdersByClass(classroom) {
    console.log(`getOrdersByClass chiamato con classe: "${classroom}"`);
    const orders2 = Array.from(this.orders.values());
    const result = [];
    for (const order of orders2) {
      const user = this.users.get(order.userId);
      console.log(`Verificando ordine ${order.id}, utente: ${user?.firstName} ${user?.lastName}, classe utente: "${user?.classRoom}"`);
      if (user && user.classRoom && classroom && user.classRoom.toLowerCase() === classroom.toLowerCase()) {
        console.log(`Ordine ${order.id} aggiunto ai risultati`);
        result.push(order);
      }
    }
    console.log(`getOrdersByClass: trovati ${result.length} ordini per la classe ${classroom}`);
    return result;
  }
  async getOrderById(id) {
    return this.orders.get(id);
  }
  async createOrder(insertOrder) {
    const id = this.orderId++;
    const order = {
      ...insertOrder,
      id,
      createdAt: /* @__PURE__ */ new Date(),
      status: insertOrder.status || "pending"
    };
    this.orders.set(id, order);
    this.saveData();
    return order;
  }
  async updateOrderStatus(id, status) {
    const existingOrder = this.orders.get(id);
    if (!existingOrder) {
      return void 0;
    }
    const updatedOrder = { ...existingOrder, status };
    this.orders.set(id, updatedOrder);
    this.saveData();
    return updatedOrder;
  }
  // Order items operations
  async getOrderItems(orderId) {
    return Array.from(this.orderItems.values()).filter(
      (item) => item.orderId === orderId
    );
  }
  async createOrderItem(insertOrderItem) {
    const id = this.orderItemId++;
    const orderItem = { ...insertOrderItem, id };
    this.orderItems.set(id, orderItem);
    this.saveData();
    return orderItem;
  }
  // Operazioni per la gestione delle classi
  async getAvailableClasses() {
    try {
      if (this.availableClasses && this.availableClasses.length > 0) {
        return this.availableClasses;
      }
      const users2 = await this.getAllUsers();
      const classes = Array.from(new Set(
        users2.map((user) => user.classRoom).filter(Boolean).filter((className) => className !== "Admin")
        // Esclude la "classe" Admin
      )).sort();
      if (classes.length === 0) {
        const defaultClasses = [
          "1A",
          "2A",
          "3A",
          "4A",
          "5A",
          "1B",
          "2B",
          "3B",
          "4B",
          "5B",
          "1C",
          "2C",
          "3C",
          "4C",
          "5C",
          "1D",
          "2D",
          "3D",
          "4D",
          "5D",
          "1E",
          "2E",
          "3E",
          "4E",
          "5E",
          "1F",
          "2F",
          "3F",
          "4F",
          "5F",
          "1G",
          "2G",
          "3G",
          "1H",
          "2H",
          "3H",
          "4H",
          "5H",
          "2L",
          "3L"
        ];
        this.availableClasses = defaultClasses;
        return defaultClasses;
      }
      this.availableClasses = classes;
      return classes;
    } catch (error) {
      console.error("Errore nel recupero delle classi:", error);
      return [];
    }
  }
  async updateAvailableClasses(classes) {
    try {
      this.availableClasses = [...classes].sort();
      Storage.saveData("availableClasses", this.availableClasses);
      return this.availableClasses;
    } catch (error) {
      console.error("Errore nell'aggiornamento delle classi:", error);
      return this.availableClasses || [];
    }
  }
};
var storage = new MemStorage();

// server/auth.ts
import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import session2 from "express-session";
import { scrypt, randomBytes, timingSafeEqual } from "crypto";
import { promisify } from "util";
var scryptAsync = promisify(scrypt);
async function hashPassword(password) {
  const salt = randomBytes(16).toString("hex");
  const buf = await scryptAsync(password, salt, 64);
  return `${buf.toString("hex")}.${salt}`;
}
async function comparePasswords(supplied, stored) {
  console.log(`Comparing password for admin check.`);
  if (stored.includes("c0ffee12deadbeef34abcd5678") || stored.includes("f1b2c3d4e5f6789abcdef123")) {
    const [hashed, salt] = stored.split(".");
    console.log("Admin login attempt, using SHA-256");
    const crypto = await import("crypto");
    const suppliedHash = crypto.createHash("sha256").update(supplied + salt).digest("hex");
    const match = suppliedHash === hashed;
    console.log(`Admin password match: ${match}`);
    return match;
  }
  try {
    console.log("Normal user login attempt, using scrypt");
    const [hashed, salt] = stored.split(".");
    if (!salt) {
      console.error("Password format error: missing salt");
      return false;
    }
    const hashedBuf = Buffer.from(hashed, "hex");
    const suppliedBuf = await scryptAsync(supplied, salt, 64);
    return timingSafeEqual(hashedBuf, suppliedBuf);
  } catch (err) {
    console.error("Error comparing passwords:", err);
    return false;
  }
}
function setupAuth(app2) {
  const sessionSettings = {
    secret: process.env.SESSION_SECRET || "school-snack-secret-key",
    resave: false,
    saveUninitialized: true,
    store: storage.sessionStore,
    cookie: {
      maxAge: 1e3 * 60 * 60 * 24,
      // 24 hours
      sameSite: "lax",
      secure: false,
      // Replit verrà eseguito su HTTP in ambiente di sviluppo
      httpOnly: true
    }
  };
  app2.set("trust proxy", 1);
  app2.use(session2(sessionSettings));
  app2.use(passport.initialize());
  app2.use(passport.session());
  passport.use(
    new LocalStrategy(async (username, password, done) => {
      try {
        const user = await storage.getUserByUsername(username);
        if (!user || !await comparePasswords(password, user.password)) {
          return done(null, false);
        } else {
          return done(null, user);
        }
      } catch (err) {
        return done(err);
      }
    })
  );
  passport.serializeUser((user, done) => done(null, user.id));
  passport.deserializeUser(async (id, done) => {
    try {
      const user = await storage.getUser(id);
      console.log("Deserializing user:", id, user ? `[${user.username}]` : "not found");
      done(null, user);
    } catch (err) {
      console.error("Error deserializing user:", id, err);
      done(err);
    }
  });
  app2.post("/api/register", async (req, res, next) => {
    try {
      const existingUser = await storage.getUserByUsername(req.body.username);
      if (existingUser) {
        return res.status(400).send("Username already exists");
      }
      const hashedPassword = await hashPassword(req.body.password);
      const user = await storage.createUser({
        ...req.body,
        password: hashedPassword
      });
      req.login(user, (err) => {
        if (err) return next(err);
        return res.status(201).json({
          id: user.id,
          username: user.username,
          firstName: user.firstName,
          lastName: user.lastName,
          classRoom: user.classRoom,
          isRepresentative: user.isRepresentative
        });
      });
    } catch (err) {
      next(err);
    }
  });
  app2.post("/api/login", passport.authenticate("local"), (req, res) => {
    const user = req.user;
    console.log("User logged in successfully:", user.username, "isUserAdmin:", user.isUserAdmin);
    return res.status(200).json({
      id: user.id,
      username: user.username,
      firstName: user.firstName,
      lastName: user.lastName,
      classRoom: user.classRoom,
      isRepresentative: user.isRepresentative,
      isAdmin: user.isAdmin,
      isUserAdmin: user.isUserAdmin
    });
  });
  app2.post("/api/logout", (req, res, next) => {
    req.logout((err) => {
      if (err) return next(err);
      res.sendStatus(200);
    });
  });
  app2.get("/api/user", (req, res) => {
    console.log("GET /api/user - Authentication status:", req.isAuthenticated());
    if (!req.isAuthenticated()) return res.sendStatus(401);
    const user = req.user;
    console.log("GET /api/user - User data:", user.username, "isUserAdmin:", user.isUserAdmin);
    return res.json({
      id: user.id,
      username: user.username,
      firstName: user.firstName,
      lastName: user.lastName,
      classRoom: user.classRoom,
      isRepresentative: user.isRepresentative,
      isAdmin: user.isAdmin,
      isUserAdmin: user.isUserAdmin
    });
  });
}

// shared/schema.ts
import { pgTable, text, serial, integer, boolean, timestamp, doublePrecision } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
var users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  classRoom: text("class_room").notNull(),
  email: text("email").notNull(),
  isRepresentative: boolean("is_representative").default(false),
  isAdmin: boolean("is_admin").default(false),
  isUserAdmin: boolean("is_user_admin").default(false)
  // Nuovo campo per gli amministratori che gestiscono gli utenti
});
var insertUserSchema = createInsertSchema(users).omit({
  id: true
});
var products = pgTable("products", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  description: text("description").notNull(),
  price: doublePrecision("price").notNull(),
  category: text("category").notNull(),
  available: boolean("available").default(true)
});
var insertProductSchema = createInsertSchema(products).omit({
  id: true
});
var orders = pgTable("orders", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  status: text("status").notNull().default("pending"),
  total: doublePrecision("total").notNull(),
  createdAt: timestamp("created_at").defaultNow(),
  orderDate: timestamp("order_date").notNull()
});
var insertOrderSchema = createInsertSchema(orders).omit({
  id: true,
  createdAt: true
});
var orderItems = pgTable("order_items", {
  id: serial("id").primaryKey(),
  orderId: integer("order_id").notNull().references(() => orders.id),
  productId: integer("product_id").notNull().references(() => products.id),
  quantity: integer("quantity").notNull(),
  price: doublePrecision("price").notNull()
});
var insertOrderItemSchema = createInsertSchema(orderItems).omit({
  id: true
});

// server/routes.ts
import { z } from "zod";
async function registerRoutes(app2) {
  setupAuth(app2);
  app2.get("/api/admin/classes", async (req, res) => {
    try {
      const classes = await storage.getAvailableClasses();
      res.json(classes);
    } catch (error) {
      console.error("Errore nel recupero delle classi:", error);
      res.status(500).json({ error: "Errore nel recupero delle classi" });
    }
  });
  app2.post("/api/admin/classes", async (req, res) => {
    try {
      if (req.isAuthenticated() && !req.user?.isUserAdmin) {
        return res.status(403).json({ error: "Non autorizzato" });
      }
      const { classes } = req.body;
      if (!Array.isArray(classes)) {
        return res.status(400).json({ error: "Formato non valido" });
      }
      const updatedClasses = await storage.updateAvailableClasses(classes);
      res.json(updatedClasses);
    } catch (error) {
      console.error("Errore nell'aggiornamento delle classi:", error);
      res.status(500).json({ error: "Errore nell'aggiornamento delle classi" });
    }
  });
  app2.get("/api/products", async (req, res) => {
    try {
      const category = req.query.category;
      let products2;
      if (category && category !== "Tutti") {
        products2 = await storage.getProductsByCategory(category);
      } else {
        products2 = await storage.getProducts();
      }
      res.json(products2);
    } catch (error) {
      console.error("Error fetching products:", error);
      res.status(500).json({ message: "Failed to fetch products" });
    }
  });
  app2.get("/api/products/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const product = await storage.getProduct(id);
      if (!product) {
        return res.status(404).json({ message: "Product not found" });
      }
      res.json(product);
    } catch (error) {
      console.error("Error fetching product:", error);
      res.status(500).json({ message: "Failed to fetch product" });
    }
  });
  app2.post("/api/products", async (req, res) => {
    try {
      console.log("POST /api/products - Authentication status:", req.isAuthenticated(), "- User:", req.user);
      const productData = {
        name: req.body.name,
        description: req.body.description,
        price: req.body.price,
        category: req.body.category,
        available: req.body.available !== void 0 ? req.body.available : true
      };
      const validatedProductData = insertProductSchema.parse(productData);
      const product = await storage.createProduct(validatedProductData);
      res.status(200).json(product);
    } catch (error) {
      console.error("Error creating product:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ message: "Invalid product data", errors: error.errors });
      } else {
        res.status(500).json({ message: "Failed to create product" });
      }
    }
  });
  app2.delete("/api/products/:id", async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      if (!req.user?.isAdmin) {
        return res.status(403).json({ message: "Forbidden" });
      }
      const id = parseInt(req.params.id);
      const result = await storage.deleteProduct(id);
      if (!result) {
        return res.status(404).json({ message: "Product not found" });
      }
      res.status(200).json({ message: "Product deleted successfully" });
    } catch (error) {
      console.error("Error deleting product:", error);
      res.status(500).json({ message: "Failed to delete product" });
    }
  });
  app2.get("/api/orders", async (req, res) => {
    try {
      console.log("GET /api/orders - Authentication status:", req.isAuthenticated(), "User:", req.user?.id);
      const userId = req.user?.id || (req.query.userId ? parseInt(req.query.userId) : void 0);
      if (!userId) {
        return res.status(400).json({ message: "User ID is required" });
      }
      const orders2 = await storage.getOrdersByUser(userId);
      const ordersWithItems = await Promise.all(
        orders2.map(async (order) => {
          const items = await storage.getOrderItems(order.id);
          return {
            ...order,
            items
          };
        })
      );
      res.json(ordersWithItems);
    } catch (error) {
      console.error("Error fetching orders:", error);
      res.status(500).json({ message: "Failed to fetch orders" });
    }
  });
  app2.post("/api/orders", async (req, res) => {
    try {
      const userId = req.user?.id || req.body.userId;
      if (!userId) {
        return res.status(400).json({ message: "User ID is required" });
      }
      const orderData = {
        userId,
        total: req.body.total,
        status: "pending",
        orderDate: new Date(req.body.orderDate || /* @__PURE__ */ new Date())
      };
      const validatedOrderData = insertOrderSchema.parse(orderData);
      const order = await storage.createOrder(validatedOrderData);
      const cartItemsSchema = z.array(z.object({
        product: z.object({
          id: z.number(),
          price: z.number()
        }),
        quantity: z.number().min(1)
      }));
      const validatedCartItems = cartItemsSchema.parse(req.body.items);
      await Promise.all(
        validatedCartItems.map(async (item) => {
          const orderItemData = {
            orderId: order.id,
            productId: item.product.id,
            quantity: item.quantity,
            price: item.product.price
          };
          await storage.createOrderItem(orderItemData);
        })
      );
      res.status(201).json(order);
    } catch (error) {
      console.error("Error creating order:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ message: "Invalid order data", errors: error.errors });
      } else {
        res.status(500).json({ message: "Failed to create order" });
      }
    }
  });
  app2.get("/api/admin/orders", async (req, res) => {
    try {
      console.log("GET /api/admin/orders - Authentication status:", req.isAuthenticated(), "- User:", req.user);
      const allOrders = await storage.getOrders();
      console.log(`Ottenuti ${allOrders.length} ordini totali per l'amministratore`);
      const ordersWithDetails = await Promise.all(
        allOrders.map(async (order) => {
          const items = await storage.getOrderItems(order.id);
          const user = await storage.getUser(order.userId);
          return {
            ...order,
            items,
            user: user ? {
              id: user.id,
              firstName: user.firstName,
              lastName: user.lastName,
              classRoom: user.classRoom
            } : {
              id: 0,
              firstName: "Utente",
              lastName: "Sconosciuto",
              classRoom: "N/A"
            }
          };
        })
      );
      console.log(`Inviati ${ordersWithDetails.length} ordini completi all'amministratore`);
      res.json(ordersWithDetails);
    } catch (error) {
      console.error("Error fetching admin orders:", error);
      res.status(500).json({ message: "Failed to fetch admin orders" });
    }
  });
  app2.get("/api/admin/orders/class/:classroom", async (req, res) => {
    try {
      console.log("GET /api/admin/orders/class/:classroom - Authentication status:", req.isAuthenticated(), "- User:", req.user, "- Classroom:", req.params.classroom);
      const classroom = decodeURIComponent(req.params.classroom);
      console.log("Classe decodificata:", classroom);
      if (!classroom) {
        return res.status(400).json({ message: "Classroom parameter is required" });
      }
      const orders2 = await storage.getOrdersByClass(classroom);
      console.log(`Ottenuti ${orders2.length} ordini per la classe ${classroom}`);
      const ordersWithDetails = await Promise.all(
        orders2.map(async (order) => {
          const items = await storage.getOrderItems(order.id);
          const user = await storage.getUser(order.userId);
          return {
            ...order,
            items,
            user: user ? {
              id: user.id,
              firstName: user.firstName,
              lastName: user.lastName,
              classRoom: user.classRoom
            } : null
          };
        })
      );
      console.log(`Inviati ${ordersWithDetails.length} ordini completi per la classe ${classroom}`);
      res.json(ordersWithDetails);
    } catch (error) {
      console.error("Error fetching class orders:", error);
      res.status(500).json({ message: "Failed to fetch class orders" });
    }
  });
  app2.patch("/api/admin/orders/:id/status", async (req, res) => {
    try {
      console.log("PATCH /api/admin/orders/:id/status - Authentication status:", req.isAuthenticated(), "- User:", req.user, "- Order ID:", req.params.id, "- Status:", req.body.status);
      const id = parseInt(req.params.id);
      const { status } = req.body;
      const updatedOrder = await storage.updateOrderStatus(id, status);
      if (!updatedOrder) {
        return res.status(404).json({ message: "Order not found" });
      }
      res.json(updatedOrder);
    } catch (error) {
      console.error("Error updating order status:", error);
      res.status(500).json({ message: "Failed to update order status" });
    }
  });
  app2.get("/api/admin/users", async (req, res) => {
    try {
      console.log("GET /api/admin/users - Authentication status:", req.isAuthenticated());
      const users2 = await storage.getAllUsers();
      const usersWithoutPasswords = users2.map((user) => {
        const { password, ...userWithoutPassword } = user;
        return userWithoutPassword;
      });
      res.json(usersWithoutPasswords);
    } catch (error) {
      console.error("Error fetching users:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });
  app2.post("/api/admin/users", async (req, res) => {
    try {
      const userData = {
        username: req.body.username,
        password: req.body.password,
        firstName: req.body.firstName,
        lastName: req.body.lastName,
        classRoom: req.body.classRoom,
        email: req.body.email || req.body.username,
        // Se email non viene fornita, usa username
        isRepresentative: req.body.isRepresentative,
        isAdmin: req.body.isAdmin,
        isUserAdmin: req.body.isUserAdmin
      };
      const validatedUserData = insertUserSchema.parse(userData);
      const existingUser = await storage.getUserByUsername(validatedUserData.username);
      if (existingUser) {
        return res.status(400).json({ message: "Username already exists" });
      }
      const crypto = await import("crypto");
      const salt = crypto.randomBytes(16).toString("hex");
      const scrypt2 = crypto.scryptSync;
      const hashedPassword = crypto.scryptSync(validatedUserData.password, salt, 64).toString("hex") + "." + salt;
      const userToCreate = {
        ...validatedUserData,
        password: hashedPassword
      };
      const user = await storage.createUser(userToCreate);
      const { password, ...userWithoutPassword } = user;
      res.status(201).json(userWithoutPassword);
    } catch (error) {
      console.error("Error creating user:", error);
      if (error instanceof z.ZodError) {
        res.status(400).json({ message: "Invalid user data", errors: error.errors });
      } else {
        res.status(500).json({ message: "Failed to create user" });
      }
    }
  });
  app2.patch("/api/admin/users/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const existingUser = await storage.getUser(id);
      if (!existingUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const updateData = {};
      if (req.body.password) {
        const crypto = await import("crypto");
        const salt = crypto.randomBytes(16).toString("hex");
        const hashedPassword = crypto.scryptSync(req.body.password, salt, 64).toString("hex") + "." + salt;
        updateData.password = hashedPassword;
      }
      if (req.body.firstName) updateData.firstName = req.body.firstName;
      if (req.body.lastName) updateData.lastName = req.body.lastName;
      if (req.body.classRoom) updateData.classRoom = req.body.classRoom;
      if (req.body.email) updateData.email = req.body.email;
      if (req.body.isRepresentative !== void 0) updateData.isRepresentative = req.body.isRepresentative;
      if (req.body.isAdmin !== void 0) updateData.isAdmin = req.body.isAdmin;
      if (req.body.isUserAdmin !== void 0) updateData.isUserAdmin = req.body.isUserAdmin;
      const updatedUser = await storage.updateUser(id, updateData);
      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const { password, ...userWithoutPassword } = updatedUser;
      res.json(userWithoutPassword);
    } catch (error) {
      console.error("Error updating user:", error);
      res.status(500).json({ message: "Failed to update user" });
    }
  });
  app2.delete("/api/admin/users/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const existingUser = await storage.getUser(id);
      if (!existingUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const deleted = await storage.deleteUser(id);
      if (!deleted) {
        return res.status(400).json({ message: "Failed to delete user" });
      }
      res.status(200).json({ message: "User deleted successfully" });
    } catch (error) {
      console.error("Error deleting user:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app2.delete("/api/admin/users/students/all", async (req, res) => {
    try {
      const allUsers = await storage.getAllUsers();
      const usersToDelete = allUsers;
      let deletedCount = 0;
      for (const user of usersToDelete) {
        const success = await storage.deleteUser(user.id);
        if (success) {
          deletedCount++;
        }
      }
      res.status(200).json({
        message: `${deletedCount} utenti eliminati con successo`,
        count: deletedCount
      });
    } catch (error) {
      console.error("Error deleting users:", error);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  const httpServer = createServer(app2);
  return httpServer;
}

// server/vite.ts
import express from "express";
import fs2 from "fs";
import path3, { dirname as dirname2 } from "path";
import { fileURLToPath as fileURLToPath2 } from "url";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import themePlugin from "@replit/vite-plugin-shadcn-theme-json";
import path2, { dirname } from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
import { fileURLToPath } from "url";
var __filename = fileURLToPath(import.meta.url);
var __dirname = dirname(__filename);
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    themePlugin(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path2.resolve(__dirname, "client", "src"),
      "@shared": path2.resolve(__dirname, "shared"),
      "@assets": path2.resolve(__dirname, "attached_assets")
    }
  },
  root: path2.resolve(__dirname, "client"),
  build: {
    outDir: path2.resolve(__dirname, "dist/public"),
    emptyOutDir: true
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var __filename2 = fileURLToPath2(import.meta.url);
var __dirname2 = dirname2(__filename2);
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path3.resolve(
        __dirname2,
        "..",
        "client",
        "index.html"
      );
      let template = await fs2.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path3.resolve(__dirname2, "public");
  if (!fs2.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path3.resolve(distPath, "index.html"));
  });
}

// server/index.ts
var app = express2();
app.use(express2.json());
app.use(express2.urlencoded({ extended: false }));
app.use((req, res, next) => {
  const start = Date.now();
  const path4 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path4.startsWith("/api")) {
      let logLine = `${req.method} ${path4} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const port = 5e3;
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true
  }, () => {
    log(`serving on port ${port}`);
  });
})();